from tinyec import registry
from tinyec.ec import Point
import secrets, hashlib
from aes import encrypt_AES_GCM, decrypt_AES_GCM

curve = registry.get_curve('secp256r1')

class prime256v1:
    '''
    example of a class that holds the parameters for the prime256v1 curve
    '''
    def __init__(self) -> None:
        # also known as secp256r1 or P-256
        self.name = "prime256v1"

        # p is the prime for modulo
        self.p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff

        # a and b are the coefficients for the elliptic curve equation
        self.a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
        self.b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b

        # G is the generator point
        self.G = (0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)
        
        # n is the cardinality of the curve
        self.n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551

        # h is the cofactor of the subgroup generated by G
        # (h = #E(F_p)/n = number of points that satisfy curve equation / cardinality of chosen subgroup)
        self.h = 0x1

def ecc_point_to_256_bit_key(point):
    '''hash the x and y coordinates of given ECC point to get desired (AES) key length'''
    sha = hashlib.sha256(int.to_bytes(point.x, 32, 'big'))
    sha.update(int.to_bytes(point.y, 32, 'big'))

    return sha.digest()

def encrypt_ECC(msg: bytes, pubKey):
    '''encrypt a message with a given ECC public key

    returns (ciphertext, nonce, authTag, x, y) tuple'''
    # generate shared secret key
    sharedKey = secrets.randbelow(curve.field.n)

    # calculate shared ECC key
    sharedECCKey = sharedKey * pubKey # sharedECCKey = sharedKey * (privKey * curve.g)

    # generate AES key from shared ECC key
    secretKey = ecc_point_to_256_bit_key(sharedECCKey)

    # encrypt message with AES key
    ciphertext, nonce, authTag = encrypt_AES_GCM(msg, secretKey)

    # obfuscate the shared key
    sharedPoint = sharedKey * curve.g
    
    return (ciphertext, nonce, authTag, sharedPoint.x, sharedPoint.y)

def decrypt_ECC(encryptedMsg: tuple, privKey) -> bytes:
    '''decrypt a message with a given ECC private key

    message is expected in format (ciphertext, nonce, authTag, x, y)

    returns plaintext'''
    # extract data from encrypted message
    (ciphertext, nonce, authTag, x, y) = encryptedMsg

    # reconstruct point from x and y (needed to access EC operations on the point)
    sharedPoint = Point(curve, x, y)

    # calculate shared ECC key
    sharedECCKey = privKey * sharedPoint # sharedECCKey = privKey * (sharedKey * curve.g)

    # generate AES key from shared ECC key
    secretKey = ecc_point_to_256_bit_key(sharedECCKey)

    # decrypt message with AES key
    plaintext = decrypt_AES_GCM(ciphertext, nonce, authTag, secretKey)

    return plaintext