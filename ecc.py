from tinyec import registry
from tinyec.ec import Point
import hashlib
from aes import encrypt_AES_GCM, decrypt_AES_GCM

curve = registry.get_curve('secp256r1')

class prime256v1:
    """example of a class that holds the parameters for the prime256v1 curve"""
    
    def __init__(self) -> None:
        # also known as secp256r1 or P-256
        self.name = "prime256v1"

        # p is the prime for modulo
        self.p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff

        # a and b are the coefficients for the elliptic curve equation
        self.a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
        self.b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b

        # G is the generator point
        self.G = (0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)
        
        # n is the cardinality of the curve
        self.n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551

        # h is the cofactor of the subgroup generated by G
        # (h = #E(F_p)/n = number of points that satisfy curve equation / cardinality of chosen subgroup)
        self.h = 0x1

def ecc_point_to_256_bit_key(point: Point) -> bytes:
    """hash the x and y coordinates of given ECC point to get desired (AES) key length

    Args:
        point (Point): ECC point

    Returns:
        bytes: 256-bit key
    """
    sha = hashlib.sha256(int.to_bytes(point.x, 32, 'big'))
    sha.update(int.to_bytes(point.y, 32, 'big'))

    return sha.digest()

def encrypt_ECC(msg: bytes, sharedKey: Point) -> tuple:
    """encrypt a message with a given shared ECC key

    Args:
        msg (bytes): message to be encrypted
        sharedKey (Point): shared ECC key

    Returns:
        tuple: (ciphertext, nonce, authTag)
    """
    # derive AES key from shared ECC key
    secretKey = ecc_point_to_256_bit_key(sharedKey)

    # encrypt message with AES key
    ciphertext, nonce, authTag = encrypt_AES_GCM(msg, secretKey)

    return (ciphertext, nonce, authTag)

def decrypt_ECC(encryptedMsg: tuple, sharedKey: Point) -> bytes:
    """decrypt a message with a given shared ECC key

    Args:
        encryptedMsg (tuple): (ciphertext, nonce, authTag)
        sharedKey (Point): shared ECC key

    Returns:
        bytes: encoded message
    """
    # extract data from encrypted message
    (ciphertext, nonce, authTag) = encryptedMsg

    # derive AES key from shared ECC key
    secretKey = ecc_point_to_256_bit_key(sharedKey)

    # decrypt message with AES key
    plaintext = decrypt_AES_GCM(ciphertext, nonce, authTag, secretKey)

    return plaintext